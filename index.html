<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Debug WebXR FPS - Find the Issue</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000;
    }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 16px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
    #debug {
      position: absolute;
      top: 10px;
      right: 10px;
      color: yellow;
      font-size: 12px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      max-height: 400px;
      overflow-y: auto;
    }
    #testButton {
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 18px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <button id="startButton">Start AR Shooter</button>
  <button id="testButton">Test WebXR Support</button>
  <div id="info" style="display: none;">
    Score: <span id="score">0</span> | Health: <span id="health">100</span>
  </div>
  <div id="debug">Starting debug...</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.150.1/examples/jsm/loaders/GLTFLoader.js';

    let camera, scene, renderer;
    let controller;
    let gltfLoader;
    let modelLoaded = false;
    
    // Game state
    let score = 0;
    let health = 100;
    let enemies = [];
    let bullets = [];
    
    // Debug function with timestamp
    function debug(msg) {
      const timestamp = new Date().toLocaleTimeString();
      const fullMsg = `[${timestamp}] ${msg}`;
      console.log(fullMsg);
      const debugEl = document.getElementById('debug');
      debugEl.innerHTML += fullMsg + '<br>';
      debugEl.scrollTop = debugEl.scrollHeight;
    }
    
    debug("üöÄ Starting app initialization...");
    
    init();

    function init() {
      debug("üìã init() called");
      
      try {
        scene = new THREE.Scene();
        debug("‚úì Scene created");
        
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        debug("‚úì Camera created");
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        debug("‚úì Renderer created");
        
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        debug("‚úì Renderer configured and added to DOM");

        // Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        debug("‚úì Lighting added");

        gltfLoader = new GLTFLoader();
        debug("‚úì GLTF Loader created");
        
        // Test Three.js is working by adding a cube
        const testGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const testMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const testCube = new THREE.Mesh(testGeometry, testMaterial);
        testCube.position.set(0, 0, -2);
        scene.add(testCube);
        debug("‚úì Test cube added to scene");
        
        // Render once to make sure Three.js works
        renderer.render(scene, camera);
        debug("‚úì Initial render complete");
        
        // Try to load the model
        loadModel();
        
        // Set up event listeners
        document.getElementById('startButton').addEventListener('click', testARSession);
        document.getElementById('testButton').addEventListener('click', testWebXRSupport);
        debug("‚úì Event listeners added");
        
      } catch (error) {
        debug(`‚ùå ERROR in init(): ${error.message}`);
        debug(`‚ùå Stack: ${error.stack}`);
      }
    }

    async function testWebXRSupport() {
      debug("üîç Testing WebXR support...");
      
      if (!navigator.xr) {
        debug("‚ùå navigator.xr is not available");
        return;
      }
      debug("‚úì navigator.xr exists");
      
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        debug(`WebXR AR supported: ${supported}`);
        
        if (!supported) {
          debug("‚ùå AR not supported on this device");
          // Try VR instead
          const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
          debug(`WebXR VR supported: ${vrSupported}`);
        }
      } catch (error) {
        debug(`‚ùå Error checking WebXR support: ${error.message}`);
      }
    }

    function loadModel() {
      debug("üì¶ Starting model load...");
      
      // Check if bat.glb file exists by trying to fetch it first
      fetch('bat.glb')
        .then(response => {
          debug(`Fetch bat.glb response: ${response.status} ${response.statusText}`);
          if (response.ok) {
            debug("‚úì bat.glb file exists, proceeding with GLTF load...");
            actuallyLoadModel();
          } else {
            debug("‚ùå bat.glb file not found, using fallback");
            createFallbackModel();
          }
        })
        .catch(error => {
          debug(`‚ùå Fetch error: ${error.message}`);
          debug("Using fallback model instead");
          createFallbackModel();
        });
    }

    function actuallyLoadModel() {
      debug("üéØ Loading bat.glb with GLTFLoader...");
      
      gltfLoader.load(
        'bat.glb',
        (gltf) => {
          debug("‚úì GLTF loaded successfully!");
          debug(`Scene children: ${gltf.scene.children.length}`);
          
          // Inspect the loaded model
          gltf.scene.traverse((child, index) => {
            debug(`Child ${index}: ${child.type} ${child.name || '(unnamed)'}`);
            if (child.isMesh) {
              debug(`  - Mesh found: geometry=${!!child.geometry}, material=${!!child.material}`);
              if (child.geometry) {
                debug(`  - Geometry: vertices=${child.geometry.attributes.position?.count || 'unknown'}`);
              }
            }
          });
          
          // Add the model to scene for testing
          const testModel = gltf.scene.clone();
          testModel.position.set(1, 0, -2); // Position next to green cube
          testModel.scale.set(0.5, 0.5, 0.5);
          scene.add(testModel);
          
          modelLoaded = true;
          debug("‚úì Model added to scene and ready for use");
          
          // Re-render
          renderer.render(scene, camera);
        },
        (progress) => {
          if (progress.total > 0) {
            const percent = Math.round(progress.loaded / progress.total * 100);
            debug(`Loading progress: ${percent}%`);
          }
        },
        (error) => {
          debug(`‚ùå GLTF load error: ${error.message}`);
          debug(`‚ùå Error type: ${error.constructor.name}`);
          createFallbackModel();
        }
      );
    }

    function createFallbackModel() {
      debug("üîß Creating fallback red cube model");
      
      const fallbackGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
      const fallbackMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      const fallbackModel = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
      fallbackModel.position.set(-1, 0, -2); // Position to left of green cube
      scene.add(fallbackModel);
      
      modelLoaded = true;
      debug("‚úì Fallback model created and added");
      
      // Re-render
      renderer.render(scene, camera);
    }

    async function testARSession() {
      debug("üéÆ AR Session button clicked!");
      
      if (!navigator.xr) {
        debug("‚ùå WebXR not supported");
        return;
      }
      
      try {
        debug("üîç Checking AR support...");
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        debug(`AR supported: ${supported}`);
        
        if (!supported) {
          debug("‚ùå AR not supported, cannot start session");
          return;
        }
        
        debug("üöÄ Requesting AR session...");
        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['local-floor'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });
        
        debug("‚úì AR session granted!");
        onSessionStarted(session);
        
      } catch (error) {
        debug(`‚ùå AR session failed: ${error.message}`);
        debug(`‚ùå Error name: ${error.name}`);
        
        // Try without dom-overlay
        try {
          debug("üîÑ Retrying without DOM overlay...");
          const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local-floor']
          });
          debug("‚úì AR session granted (without DOM overlay)!");
          onSessionStarted(session);
        } catch (error2) {
          debug(`‚ùå Second attempt failed: ${error2.message}`);
        }
      }
    }

    function onSessionStarted(session) {
      debug("üéØ AR Session started successfully!");
      
      document.getElementById('startButton').style.display = 'none';
      document.getElementById('testButton').style.display = 'none';
      document.getElementById('info').style.display = 'block';
      
      renderer.xr.setSession(session);
      debug("‚úì Renderer XR session set");

      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);
      debug("‚úì Controller added");

      // Add gun to controller
      const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08, 5);
      geometry.rotateX(-Math.PI / 2);
      const material = new THREE.MeshPhysicalMaterial({
        color: 0x444444,
        roughness: 0.6,
        metalness: 0.8
      });
      const gun = new THREE.Mesh(geometry, material);
      gun.position.z = -0.05;
      controller.add(gun);
      debug("‚úì Gun added to controller");

      renderer.setAnimationLoop(render);
      debug("‚úì Animation loop started");
      
      // Add some test enemies
      setTimeout(() => {
        spawnTestEnemies();
      }, 2000);
    }

    function spawnTestEnemies() {
      debug("üëæ Spawning test enemies...");
      
      for (let i = 0; i < 3; i++) {
        const enemy = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.2),
          new THREE.MeshPhongMaterial({ color: 0xff0000 })
        );
        
        enemy.position.set(
          (i - 1) * 0.5,  // Spread them out
          1,
          -3
        );
        
        enemy.userData = { health: 1, isEnemy: true };
        scene.add(enemy);
        enemies.push(enemy);
      }
      
      debug(`‚úì Spawned ${enemies.length} test enemies`);
    }

    function onSelect() {
      debug("üí• Controller select pressed - shooting!");
      
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.02),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );

      bullet.position.setFromMatrixPosition(controller.matrixWorld);
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(controller.quaternion);
      
      bullet.userData = {
        velocity: direction.multiplyScalar(10),
        life: 2
      };

      scene.add(bullet);
      bullets.push(bullet);
      debug("‚úì Bullet fired");
    }

    function updateGame(delta) {
      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
        bullet.userData.life -= delta;
        
        if (bullet.userData.life <= 0) {
          scene.remove(bullet);
          bullets.splice(i, 1);
          continue;
        }

        // Check collision with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (bullet.position.distanceTo(enemy.position) < 0.3) {
            debug("üéØ Enemy hit!");
            score += 10;
            updateUI();
            scene.remove(enemy);
            enemies.splice(j, 1);
            scene.remove(bullet);
            bullets.splice(i, 1);
            break;
          }
        }
      }
      
      // Animate enemies
      enemies.forEach(enemy => {
        enemy.rotation.y += delta;
      });
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('health').textContent = health;
    }

    function render(time, frame) {
      const delta = Math.min(0.05, (time - (window.lastTime || time)) * 0.001);
      window.lastTime = time;
      
      if (frame) {
        updateGame(delta);
      }
      
      renderer.render(scene, camera);
    }

    // Error handling
    window.addEventListener('error', (event) => {
      debug(`‚ùå Global error: ${event.error?.message || event.message}`);
    });

    debug("‚úì Script loaded completely");
  </script>
</body>
</html>
